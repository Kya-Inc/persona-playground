{
    "metadata": {
        "video_id": "NRwA-uHkQlU",
        "title": "Proof of Stake Vitalik Buterin Technion Cyber and Computer Security Summer School",
        "link": "https://www.youtube.com/watch?v=NRwA-uHkQlU",
        "duration": "33:17",
        "channel_name": "Technion"
    },
    "transcript": {
        "0": "okay proof of steak so I'll start off for this discussion by talking a bit more about and kind of clarifying the role that proof-of-work has in existing of watching consensus systems because there are a lot of misconceptions this so one key point is that bitcoin aetherium and similar systems are open permissionless networks and their networks where anyone can participate and where the entire network is just made up of just some people who are from anywhere in the world core participating and there are no kind of privileged actors there are no participants with any kind of identity is there but basically everyone is either anonymous or if they're anonymous in the system had the system itself has ",
        "1": "no way of telling who is it who isn't so it's this kind of it it's this kind of environment which in some would it is different from a lot of more traditional security settings right so it's like you should all security settings you know you might have met your like you might say things like you have in people running the system and as long as six of them are honest then the system works and you can see how that might make sense if those 10 people are major banks or you know what governments or just like very trustworthy individuals but if these two people are just random anonymous people then you have kind of you have different kinds of considerations that you have to deal with and proof-of-work is part of the kind of solution that deals that problem specifically so the system in a ball chain has to agree on some kind of canonical order of transactions it has to agree on you know this happened first then this happened then this happened and this happened and you can think ",
        "2": "agreements as being some kind of voting like there's obviously a lot of like very plain nuances and complexities and business in fault tolerance research I'll go into a few of them later for now think of it as being voting people vote on what the order of transactions is but if you have think they need to have some way of counting who is eligible to vote and so the problem you have is something called a simple attack so a simple attack B is fairly simple basically you could imagine a system where you have some number of participants and then here you have a bad guy coming in now the bad guy wants to take over the system the bad guy take over the voting process and he wants to be able to just basically shift the votes arbitrarily do whatever he wants reverse transactions do all sorts of nasty stuff so what the bad guy is gonna do is on his computer he is gonna spin a huge number of virtual machines and with each virtual machine he is gonna connect to the network separately and he's gonna pretend that each and every one of these ",
        "3": "virtual machines are an independent computer and so now even though the attacker is one guy he's got 12 fake identities the good guys have four identities and so it looks like the attacker has 75% of the entire system and the attacker can do all this with just one computer does everyone understand why similar attacks are bad cool okay the role of proof-of-work is that it is an economic defense against civil attacks so the idea basically is that that in order to have one unit of participation in voting you have to prove ownership of some number of dollars worth of computer heart and the way that you prove ownership of computer hardware and you need to prove ongoing ownership of computer hardware so once thought so and you can't just like keep on trading your computer around the way you think you're going owner here with computer hardware is basically by running computations on in 24/7 the fully exhausted computers computational capacity this is the old ",
        "4": "way to prove ongoing ownership of a computer right so basically approve ownership of a computer running computations on it and uploading the results to the network now how do we make this verifiable basically it has to be some computation which is hard to perform and easy to verify so in Bitcoin the general idea here is that people like there are a bunch of nodes in the network and these nodes are miners and they try to create blocks and in order for a block to be valid the hash of the block has to start with a bunch of zeros right now in order to find the blockers hashed a little bunch of zeros you have to keep trying random blocks over and over again until eventually you find a solution that's good and then when you find a solution you can broadcast it and this way basically you're kind of problem basically the your probability of creating a block is going to be in the long run proportional to the number the ",
        "5": "amount of computing power that you have if someone has three times more computing power then you're going to make more three times and three times more often than you and the mythically is how voting is in Bitcoin right so basically I'm every computer or in the network which is mining keeps solving these math puzzles in the purpose of these math puzzles is basically to show that actually are an independent unit of economic resource and so if in order for an attacker to get 51% in this moaning in the smoking and voting game the attacker actually has to have more economic resources put into mining than every other actor in the mining ecosystem put together so this is supposed to create a firm a fairly high security model now perfect thing it's basically the idea with proof of stake is instead of using computation as the limiting economic resource you use digital assets inside the system so ",
        "6": "instead of saying 1,000 dollars of computing Hardware one vote it's 1,000 dollars of Bitcoin one vote or 1,000 dollars of ether one vote and the reason why this is interesting is because proving ownership of digital assets is easy all you do is you just make a digital signature the blockchain itself already keeps track of how many of how many units are ether everyone has and so all you need to do is just make a signature and prove that you as the person who has that particular account or voting for some particular block so the goal of proof of stake is both are still goals one of them is that I believe proof of State can actually substantially integrate security but the second one is that perverse stake can basically dramatically reduce the energy consumption and dramatically reduce the economic cost of a public in consensus because instead of proving like this doing this an incredibly inefficient kind of trick of proving ",
        "7": "ownership of computers outside the system by running on 24/7 you're proving ownership of assets inside the system by making a digital signature there's two major flavors of proof of stake so the first major favor of proof of stake is something called chain based group of stake and this is the older kind a flavor a proof of stake that has existed since the rounds without leaven and it attempts to very closely replicate proof of work right so in proof of work you have about you each a ball chain and you have people not constantly trying to create blocks and the blocks form a chain and each miners probability of being able to create a block during any particular poem during any particular interval of time is proportional to the key amount of computing power that's a particular my hat you have twice as much computer computing power that means that you can burn with you you can run through different hashes twice as ",
        "8": "quickly and so it's twice as likely that you get lucky and you find and you find a valid block in perverse take basic chain based POS tries to do the same thing he tries to closely replicate proof of work by just explicitly giving every coin holder some chance per second of being assigns the right to create a block so I have one coin every second I have a chance of one in a million of being a most agree to block you have to me coins every block or every second you have a chance of three in a million of being able to create a block someone has 20 points every second they have a 20 in a million chance of being able to create a bit so this is the main reason why this was attractive is basically because number one it's simple number two it works like proof of work and so it feels kind of intuitive and attractive right now as we're going to find out there actually are probably two major pitfalls to this kind of chain ",
        "9": "base proof of snake algorithms and we still give ones so the first one is orange even a random number manipulation so in proof of work you have this eye you have this mechanism where any minor has some chance per second or being able to create a valid block but there's no way to predict ahead of time who it's going to be right every minor actually really does from the point of view of their private knowledge have some particular chance some probability per second of creating a block and you can't predict ahead of time you know who's going to get lucky or one because if you could then that means that you already know how to create a block so this actually is a kind of fairly important security property for because it basically means that there isn't when it removes a large category of possible ways of kind of manipulating in the blockchain in or does it try to get your thing in a proof of state you do not have this kind of ",
        "10": "external source of randomness or this external source of implied randomness that comes from the the facts that people don't know what the results of hashes are gonna be ahead of time instead you have to rely randomness which is inside the system so if you have a prediction in the program the way the proofs take change chooses who gets to create blocks is by relying on randomness inside the system can the orange manipulated the problem is the random number generator has to be a deterministic function so it's a pseudo-random number generator the pseudo-random number generator is based on some seed data what do you make a block you're contributing to that seed data in step the question is can you basically can people making blocks try to manipulate the system by creating blocks that have different data right so if for example you have a system where the student ran the source of the ",
        "11": "pseudo-random number generator is a block hash then you could imagine some block maker groups take seeing but they got assigns the right to create a block making 10,000 different blocks then finding the one out of those 10,000 that maximizes their near-term future revenue and then publishing that blog so basically they just manipulate handsomeness order to in order to take their way in the future the main reason why this is bad is basically because it's a centralization risk right so basically if you have a lot of stake then you're going to have a much more you're going to have many opportunities that may appear with the randomness and so you're going to have many opportunities to improve your chances of winning even further and you could even potentially get to the point where you're producing almost all of the votes so there are people have from there gone on to come up with various different algorithms that try to ",
        "12": "mitigate this issue so basically the main challenge is right that we're trying to make a function that for some bloc determines the seed of the block and the seed of the block is supposed to determine no it's supposed to be the source of is these kind of these pseudo-random numbers the determine who is supposed to be able to create that block so here is the approximate function in in NXT the seed of the genesis is 0 the seed of a block is calculated by hashing together this seed of parent and the preserve the parent so the identity of the address that creates the parent so the idea here is that if you get assigned the ability to create block thing that you can do it to manipulate it is you can either create the block or you can not create the block now if you don't create the block then it still is one bit of manipulation but it's costly manipulation because you're denying yourself a block reward ",
        "13": "now I actually did that I actually did some mathematical analysis of this and it turns out that in some situations doing the manipulation actually is profitable but it's still only a medium-sized profits don't like an absolutely terrible things that immediately break the entire system like if there is another thing if there is another kind of kind of grind attack here by the way where basically people try to move their try to move their coins around in order to put themselves in a more favorable position but in NXT is already fixed up when the way they fix it is basically they require you to walk your address for at least one day before you can become a participant in group stage so there's this is one mechanism then there's another mechanism that's that I call it that I call R and L doesn't but it's really beast time well it's based on something else which is called R and L doesn't really have a good name of it but the idea basically is that instead of putting the people proposal the professor of the parents here you would put a value this is you which is kind of ",
        "14": "a cute reveal value so when you make the block reveal a value but this value has to be the hash free image of something that you've already committed to so the idea here is that it still preserves the property that you have only one bit of manipulation and it's cost to manipulation but because the data that determines your walk makers is hidden you have much less visibility into the consequence of your manipulated you have much less visibility into just looking you know what's gonna happen in the future if I make the block versus and what's gonna happen in the future if I don't make the block and this may be why should harder there's also another approach that was my you know bent off the nasod that's called has to do with low influence functions the idea was for influence functions is basically that the young the pseudo-random numbers get created from a range of 10,000 blocks and then you would take the majority rules the 10,000 watts so if basically each mod contain contributes a bit if the 1 bits add up to more than 5,000 you take that now you ",
        "15": "if they add up to less than 5,000 you take the oven you take the other value and the main reason why you want to do this is basically because this actually is about a hundred times more expensive simin enjoyed so this it kind of an area to research and there are different ways to do this but in general this this probably is one of the major challenges of a chain based pro stick but it is solvable the second problem and possibly a more serious problem is something called nothing at stake flaw so the idea here is that in proof of work when you're a minor if there are two block that you have to choose from then you only have one unit of computing power right and the computing power is some resource which is outside the system and so if you have a given this you outside the system then you only have you only ",
        "16": "have to choose right you have to choose either to put it on it's a kind of mine on top of chain would or mine on top of chain to or you can split fifty-fifty without so many recombination so if he split 50-50 then you know you're mining half a strong on one side I have a strong is me on the other side so your incentive is to mine on the chain and you think is most likely a win in proof of stake though the problem is that because it's using a resource inside the system you can what you can do is you can vote on both so on chain a you can try using resources in RL and Cheney and on chain B you can use the resources that are on chain B so the facts that they're in that you're using versus inside the system itself means that in this kind of event of a fork you have this ability to just and the incentive to just create blocks on top of any different chains or Forks as possible so this is a mean this is not a flaw in an honest maturity model because honest validators or not supposed to double ",
        "17": "vote but it is a flaw in the economic incentive model because it basically means that even in the absence of a malicious attacker everyone has the incentive to just vote on every chain and so basically you could imagine just never coming into consensus on thing at all now the simple into this is some form of penalty based proof of stake so the idea base here basically is that we just explicitly detect double voting and we explicitly penalize double voting if you get caught voting on side a or an side at the same time then it's a lot of money and this is how we kind of just explicitly plug the hole right we just explicitly say if you do both you lose money and therefore your only real choices are to do with this or to do this and so your vote on the chain that you think is most likely and it's gets you the convergence property so this is kind of intuitively the simple ",
        "18": "kind of kernel of how to solve nothing it's but it turns out that if we wants to we can actually go further right so there is another major school of proof of stake in this is actually the school that aetherium is a research is currently kind of looking to use for its next major version and this is deposit and penalty bait and traditional BFT based proof of stake so the here is that first of all you have some notion of a validator set and you can think of the validator set is just being the set of people who are currently participating in the consensus anyone can join as auditor by submitting a deposit so you submit some ether into into a smart contract and then after some period of time you get inducted and you become a validator validators are penalized basically for contradicting themselves so you can fit we'll talk about this in ",
        "19": "more detail later but for now you can think about this kind of abstraction now Casper is fully based on various ideas from traditional BFT theory so how many people have heard of either lamport's Byzantine generals problem or DLS or pbft or any of those okay so a lot but not all but basically even before Bitcoin there was this kind of 35 year long for the well before big win 25 year long tradition of research into distributed kind of visiting or fault tolerant algorithms in distributed systems contacts that originally were intended for use and kinda in a different environment right so originally they are meant for use and more permission environments where you have 10 operators and you want your system to serve all and these 10 operators are all semi trusted and you want your system to survive and continue working if the majority of these are all honest right so you want to be able to tolerate at least some faults but you're ",
        "20": "willing to rely on this kind of honest majority assumption because these are all participants that you and so you know you can you can trust the fact that most of them are going to do what they say they do so there is a bunch of research so their smile can we import um there's an algorithm called Gita called pbft practical Brazilian fall torrents that gets used by a lot of people in general the basically these Albert so technically based proof take is a Byzantine fault solver and consensus algorithm but these more traditional BFT rhythms tends to have stronger properties than the chain based algorithms have and the stronger property that they usually have is basically they rely much less on assumptions to do with network latency so the idea here is that if you work a chain based algorithms one of the other flow and like this includes proof of work or proved mistake one of the flaws ",
        "21": "that they often have or that they always have is that if network latency gets really high then basically the chain stops being like a chain right you have a lot of different Forks you might imagine someone produces one block then on top of that one walk three blocks get produced so there's a lot of inefficiency and then an attacker can just come along and an attacker is running on one computer and so the attacker can make a perfect chain and so the amount of well the portion of hash power in the portion of stake needed to basically outrun everyone else goes down from being 51% to potentially arbitrarily low upper potentially approaching zero percent if network latency is extremely high these algorithms have something that's called a safety under a sink which basically means that they satisfy certain safety properties regardless of how long network latency is so even if the network messages are completely unreliable and they sometimes take a second to arrive they sometimes ",
        "22": "take a minute these sometimes take an hour there is still a guarantee that these algorithms are not going to fail in certain ways it's even that these albert the if network latency ever eventually becomes normal again then these algorithms are guaranteed a succeed continue making progress so this this is the sort of the main reason why you would want to be interested in in there's actually two reasons why I want to be interested in these algorithms one of them is that it turns out that the safety proofs for these kinds of algorithms pretends three over much better into an economic context and we'll talk about why later and the other thing is that with these with these algorithms basically because these algorithms have these stronger safety properties you don't need to worry about them or so much about the worst case anymore right so you if you really wanted to you ",
        "23": "could even make an El grab lock chain that regularly finalizes blocks every four seconds but then you know that if the block time ever or if the network latency goes up to four minutes then everything else will still be fine it's just that the block time will so the block chain will slow down so the here so here are the two here are the kind of security claims that Casper tries to go after and I mean first Newton is not the first bft inspired proof of steak algorithm but it is the problem I mean probably the further the first algorithm that tries to kind of really go after both of these properties and have this kind of formal idea for both of them all the two properties are simple so the algorithm defines a notion of finality now finality is something that proof-of-work does not have and chain based proof of steak does not have but Holliday basically means lucky is set in stone and we can never go back if this block is finalized it is in a tree and ",
        "24": "it is in history forever you cannot disagree with that anymore so notice that in proof of work we never have finality because someone can always make a longer chain now we do have kind of de facto finality because of things like checkpoints but like that's not like in the protocol we don't really reach that within any reasonable period of time right so within this notion of finality would then have these two security claims the first security claim is killing simple safety you notice that accountable if T is simultaneously a claim in an honest majority model and a claim in an economic model so the claim in the illness says if two thirds of the validators are honest then the everything works everything will be fine and you're not going to have situations we are two conflicting blocks get finalized the economic claim is even stronger so remember Casper is a deposit and penalty based proof of stake in order to ",
        "25": "join the Ender Casper booster you can become a validator you have to deposit some ether and if you deposit ether then if you get caught in doing something bad then your entire ether gate can get taken away from you accountable safety claim basically says if two conflicting blocks get finalized so by conflicting we mean something like this right like does everyone understand why it's very bad if like these two blocks get finalized at the same time okay so these two these three blocks are not conflicting with each other because they're part of the same chain these two blocks that can floating because we're part of different chains and you're not supposed to be able to finalize two chains that cancelled active what with each other so if you get bored yet finalized then at least one third of the players have to have broken the rules if he breaks the rules they get and the so this is a kind of very strong way then the second claim is possible liveness impossible wideness basically ",
        "26": "says if two-thirds of the valid leaders are honest then it's always possible to finalize more blocks so let's just as you can always finalising more things so stage one for a theorem is actually a hybrid design and the hybrid design basically yes and you have a proof-of-work chain at the bottom and then on top of the proof of work chain you have this what we call kind of a finality gadget which is basically these validators and these validators basically sends these two different kinds of messages and by sending these kind of messages they can finalize points right so we have a proof-of-work chain the verb or chain grows and then for any firm for every 100th block after period of time eventually it gets finalized and once it gets finalized and you can't go back anymore so there are two kinds of messages are called prepare and commit these are kind of terms from visits from my tradition obesity and false or in algorithms but basically the ",
        "27": "idea is you have these blocks and every hundredth walk is a checkpoint in this case we're using three instead of a hundred because you can't really show a hundred things on a slide so you have these these checkpoints and then after a checkpoint every one sends these prepare messages and then after you have prepare messages every one sends to make messages and if in the normal case after these commit messages that this block gets finalized now in there are going to be cases where during one particular one particular eat so once you might have a checkpoint that doesn't get finalized because just this thing doesn't get enough messages this one doesn't get enough messages but then it's it's descendant could get finalized in the future so we can define kind of justification and finality here recursive so we basically say there's these two con there's two kinds of messages one kind of message is to prepare the other kind of message has a commit and the rules me and me we define ",
        "28": "these kind of words in this way right so we say first of all the genesis is justified and the genesis is finalized so the genesis is just like the first law can detect in the entire blockchain it's the block that everyone agrees on as part of the protocol rules then we have a rule that says if two thirds of the validators prepare sub checkpoints and this checkpoints at and every prepare message has to specify both the checkpoints and the source checkpoint if two thirds of the validators prepare some checkpoints and they claim some already justified checkpoint as a source then this check and see also becomes justified if C is justified and 2/3 of the valid leaders commit then C is finalized so in this particular case if we assume like these prepares or all prepares based off of some previous hash that was already justified then this checkpoint B after these prepares this checkpoint becomes justified and after these commences check becomes finalized so then the protocol defines a certain defines - slashing ",
        "29": "conditions in swashing conditions are basically rules that say these are things that validators are never supposed to do if you do these things then these things are kind of equivalent to voting for different things if you vote for two different things at the same time then this is bad right and you are a validator that's being malicious there is evidence of this and your entire deposit can get taken away so in general right like slashing basically missing conditions that we have our first sending two messages that contradict each other so and if a violator violates a squashy condition their deposit gets deleted so a Sailaja condition might look like this so it might say if you send to prepare messages for two different things within the same epoch so that so basically if you make a prepare for this checkpoint and make a prepare for this checkpoint then this means that you violated a swashing addition and you're depositing your entire deposit can get ",
        "30": "penalized and you can get anything get deleted this is how it's actually implemented in code so in Casper there is basically two slashing conditions so the first one basically has no double prepare so you cannot prepare two conflicting things in one epoch so this is kind of like very obviously saying you can't vote for two trajectory things at the same time and there's the second one which is commit preparer consistency and can we prepare consistency basically says if you prepare in one epoch can you specify some source but then you can't commit anywhere in the middle so the idea is that when you prepare you're supposed to be saying this is the last justified thing that I've heard of but then if you commit it to commit on something in the middle then there's clearly some justified thing in the middle that you know about and so you were contradicting yourself right so the idea is that there's we basically specify these kind of two standardized ways in which validators can contradict themselves and we actually have a medical proof that says if - in any - ",
        "31": "any competitive flirting checkpoints get finalized then at least one-third of leaders need to have broken the rules and if a validator broke the rules then there's evidence that they broke the rules evident they broke the rules can get included into the blockchain and if in the evidence gets included in the blockchain then they lose their entire deposits so that's I mean look the details of the actual be actual algorithm itself are kind of I mean probably too complex to go to kind of fully go go through right now but that's the basic idea right there's a bunch of rules of validators follow if that would leaders follow the rules cut correctly then they can finalize new blocks but if any two conflicting walks yet finalized and that means that a lot of our leaders needs needed to avoid can broken the rules and if a lot of elders broke the rules and that means who is here into our deposits which means that breaking the safety guarantee if the algorithm is extremely expensive so this is just kind of one the way that we are trying the ",
        "32": "security claim that we're trying to get out of this kind of bft inspired a proof of stake algorithm so we actually so we have formal proofs that this works we have formal proofs Ted it were we have a design that allows this to handle validator rotation we have a formal proof that that works too so this is kind of the direct that the direction that were that Casper is going so as far as the kind of of week a longer term longer term challenges for this I would say the main challenges are first of all continuing to improve kind of fine grained incentives so very fine great incentives all right how do we maximum line how do we maximally encourage people you know nots to go offline how do we penalize various cut tax had a sensation can we come up with a mechanism that combines together in the benefits of a BFC be a spoof of steak and chain based proof of steak ",
        "33": "scalability of things and you were shorting and just making the thing go faster you "
    }
}